//
// ClientMethodTests.swift
// Comprehensive tests for NEAR JSON-RPC Client Methods
//
// DO NOT EDIT: This file is auto-generated by generate_all_tests.py
//

import Testing
import Foundation
@testable import NearJsonRpcClient
@testable import NearJsonRpcTypes

// MARK: - Mock URLProtocol for Testing

class MockURLProtocol: URLProtocol {
    static var requestHandler: ((URLRequest) throws -> (HTTPURLResponse, Data))?
    static var lastRequest: URLRequest?
    
    override class func canInit(with request: URLRequest) -> Bool {
        return true
    }
    
    override class func canonicalRequest(for request: URLRequest) -> URLRequest {
        return request
    }
    
    override func startLoading() {
        guard let handler = MockURLProtocol.requestHandler else {
            fatalError("Handler is unavailable.")
        }
        
        MockURLProtocol.lastRequest = request
        
        do {
            let (response, data) = try handler(request)
            client?.urlProtocol(self, didReceive: response, cacheStoragePolicy: .notAllowed)
            client?.urlProtocol(self, didLoad: data)
            client?.urlProtocolDidFinishLoading(self)
        } catch {
            client?.urlProtocol(self, didFailWithError: error)
        }
    }
    
    override func stopLoading() {}
}

@Suite("Client Method Integration Tests", .serialized)
struct ClientMethodTests {
    
    let decoder: JSONDecoder
    let encoder: JSONEncoder
    
    init() {
        decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        
        encoder = JSONEncoder()
        encoder.keyEncodingStrategy = .convertToSnakeCase
        encoder.outputFormatting = [.prettyPrinted, .sortedKeys]
    }

    @Test("EXPERIMENTAL_changes method executes successfully with mock response")
    func testExperimentalchangesSuccess() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForEXPERIMENTALChanges.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForEXPERIMENTALChanges.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock success response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcStateChangesInBlockResponseAndRpcError_Success.json")
        setupMockSuccessResponse(with: responseData)
        
        // Execute
        let result = try await client.experimentalChanges(request)
        
        // Verify
        verifyRequest(expectedMethod: "EXPERIMENTAL_changes")
        #expect(result != nil)
    }
    
    @Test("EXPERIMENTAL_changes method handles error response correctly")
    func testExperimentalchangesError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForEXPERIMENTALChanges.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForEXPERIMENTALChanges.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock error response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcStateChangesInBlockResponseAndRpcError_Error.json")
        setupMockErrorResponse(with: responseData)
        
        // Execute & Verify
        do {
            _ = try await client.experimentalChanges(request)
            Issue.record("Expected method to throw RPC error but it succeeded")
        } catch is NearJsonRpcError {
            // Expected to catch NearJsonRpcError (including rpcError case)
            #expect(true)
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }
    
    @Test("EXPERIMENTAL_changes method handles HTTP error correctly")
    func testExperimentalchangesHTTPError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForEXPERIMENTALChanges.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForEXPERIMENTALChanges.self, from: requestData)
        let request = requestWrapper.params
        
        // Setup HTTP error response
        setupMockHTTPError(statusCode: 500)
        
        // Execute & Verify
        do {
            _ = try await client.experimentalChanges(request)
            Issue.record("Expected method to throw HTTP error but it succeeded")
        } catch let error as NearJsonRpcError {
            switch error {
            case .httpError(let statusCode):
                #expect(statusCode == 500)
            case .invalidResponse:
                // Some methods might throw invalidResponse instead
                #expect(true)
            default:
                Issue.record("Expected httpError but got: \(error)")
            }
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }

    @Test("EXPERIMENTAL_changes_in_block method executes successfully with mock response")
    func testExperimentalchangesinblockSuccess() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForEXPERIMENTALChangesInBlock.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForEXPERIMENTALChangesInBlock.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock success response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcStateChangesInBlockByTypeResponseAndRpcError_Success.json")
        setupMockSuccessResponse(with: responseData)
        
        // Execute
        let result = try await client.experimentalChangesInBlock(request)
        
        // Verify
        verifyRequest(expectedMethod: "EXPERIMENTAL_changes_in_block")
        #expect(result != nil)
    }
    
    @Test("EXPERIMENTAL_changes_in_block method handles error response correctly")
    func testExperimentalchangesinblockError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForEXPERIMENTALChangesInBlock.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForEXPERIMENTALChangesInBlock.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock error response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcStateChangesInBlockByTypeResponseAndRpcError_Error.json")
        setupMockErrorResponse(with: responseData)
        
        // Execute & Verify
        do {
            _ = try await client.experimentalChangesInBlock(request)
            Issue.record("Expected method to throw RPC error but it succeeded")
        } catch is NearJsonRpcError {
            // Expected to catch NearJsonRpcError (including rpcError case)
            #expect(true)
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }
    
    @Test("EXPERIMENTAL_changes_in_block method handles HTTP error correctly")
    func testExperimentalchangesinblockHTTPError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForEXPERIMENTALChangesInBlock.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForEXPERIMENTALChangesInBlock.self, from: requestData)
        let request = requestWrapper.params
        
        // Setup HTTP error response
        setupMockHTTPError(statusCode: 500)
        
        // Execute & Verify
        do {
            _ = try await client.experimentalChangesInBlock(request)
            Issue.record("Expected method to throw HTTP error but it succeeded")
        } catch let error as NearJsonRpcError {
            switch error {
            case .httpError(let statusCode):
                #expect(statusCode == 500)
            case .invalidResponse:
                // Some methods might throw invalidResponse instead
                #expect(true)
            default:
                Issue.record("Expected httpError but got: \(error)")
            }
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }

    @Test("EXPERIMENTAL_congestion_level method executes successfully with mock response")
    func testExperimentalcongestionlevelSuccess() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForEXPERIMENTALCongestionLevel.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForEXPERIMENTALCongestionLevel.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock success response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcCongestionLevelResponseAndRpcError_Success.json")
        setupMockSuccessResponse(with: responseData)
        
        // Execute
        let result = try await client.experimentalCongestionLevel(request)
        
        // Verify
        verifyRequest(expectedMethod: "EXPERIMENTAL_congestion_level")
        #expect(result != nil)
    }
    
    @Test("EXPERIMENTAL_congestion_level method handles error response correctly")
    func testExperimentalcongestionlevelError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForEXPERIMENTALCongestionLevel.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForEXPERIMENTALCongestionLevel.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock error response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcCongestionLevelResponseAndRpcError_Error.json")
        setupMockErrorResponse(with: responseData)
        
        // Execute & Verify
        do {
            _ = try await client.experimentalCongestionLevel(request)
            Issue.record("Expected method to throw RPC error but it succeeded")
        } catch is NearJsonRpcError {
            // Expected to catch NearJsonRpcError (including rpcError case)
            #expect(true)
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }
    
    @Test("EXPERIMENTAL_congestion_level method handles HTTP error correctly")
    func testExperimentalcongestionlevelHTTPError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForEXPERIMENTALCongestionLevel.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForEXPERIMENTALCongestionLevel.self, from: requestData)
        let request = requestWrapper.params
        
        // Setup HTTP error response
        setupMockHTTPError(statusCode: 500)
        
        // Execute & Verify
        do {
            _ = try await client.experimentalCongestionLevel(request)
            Issue.record("Expected method to throw HTTP error but it succeeded")
        } catch let error as NearJsonRpcError {
            switch error {
            case .httpError(let statusCode):
                #expect(statusCode == 500)
            case .invalidResponse:
                // Some methods might throw invalidResponse instead
                #expect(true)
            default:
                Issue.record("Expected httpError but got: \(error)")
            }
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }

    @Test("EXPERIMENTAL_genesis_config method executes successfully with mock response")
    func testExperimentalgenesisconfigSuccess() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForEXPERIMENTALGenesisConfig.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForEXPERIMENTALGenesisConfig.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock success response data
        let responseData = try loadMockJSON("JsonRpcResponseForGenesisConfigAndRpcError_Success.json")
        setupMockSuccessResponse(with: responseData)
        
        // Execute
        let result = try await client.experimentalGenesisConfig(request)
        
        // Verify
        verifyRequest(expectedMethod: "EXPERIMENTAL_genesis_config")
        #expect(result != nil)
    }
    
    @Test("EXPERIMENTAL_genesis_config method handles error response correctly")
    func testExperimentalgenesisconfigError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForEXPERIMENTALGenesisConfig.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForEXPERIMENTALGenesisConfig.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock error response data
        let responseData = try loadMockJSON("JsonRpcResponseForGenesisConfigAndRpcError_Error.json")
        setupMockErrorResponse(with: responseData)
        
        // Execute & Verify
        do {
            _ = try await client.experimentalGenesisConfig(request)
            Issue.record("Expected method to throw RPC error but it succeeded")
        } catch is NearJsonRpcError {
            // Expected to catch NearJsonRpcError (including rpcError case)
            #expect(true)
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }
    
    @Test("EXPERIMENTAL_genesis_config method handles HTTP error correctly")
    func testExperimentalgenesisconfigHTTPError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForEXPERIMENTALGenesisConfig.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForEXPERIMENTALGenesisConfig.self, from: requestData)
        let request = requestWrapper.params
        
        // Setup HTTP error response
        setupMockHTTPError(statusCode: 500)
        
        // Execute & Verify
        do {
            _ = try await client.experimentalGenesisConfig(request)
            Issue.record("Expected method to throw HTTP error but it succeeded")
        } catch let error as NearJsonRpcError {
            switch error {
            case .httpError(let statusCode):
                #expect(statusCode == 500)
            case .invalidResponse:
                // Some methods might throw invalidResponse instead
                #expect(true)
            default:
                Issue.record("Expected httpError but got: \(error)")
            }
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }

    @Test("EXPERIMENTAL_light_client_block_proof method executes successfully with mock response")
    func testExperimentallightclientblockproofSuccess() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForEXPERIMENTALLightClientBlockProof.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForEXPERIMENTALLightClientBlockProof.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock success response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcLightClientBlockProofResponseAndRpcError_Success.json")
        setupMockSuccessResponse(with: responseData)
        
        // Execute
        let result = try await client.experimentalLightClientBlockProof(request)
        
        // Verify
        verifyRequest(expectedMethod: "EXPERIMENTAL_light_client_block_proof")
        #expect(result != nil)
    }
    
    @Test("EXPERIMENTAL_light_client_block_proof method handles error response correctly")
    func testExperimentallightclientblockproofError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForEXPERIMENTALLightClientBlockProof.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForEXPERIMENTALLightClientBlockProof.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock error response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcLightClientBlockProofResponseAndRpcError_Error.json")
        setupMockErrorResponse(with: responseData)
        
        // Execute & Verify
        do {
            _ = try await client.experimentalLightClientBlockProof(request)
            Issue.record("Expected method to throw RPC error but it succeeded")
        } catch is NearJsonRpcError {
            // Expected to catch NearJsonRpcError (including rpcError case)
            #expect(true)
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }
    
    @Test("EXPERIMENTAL_light_client_block_proof method handles HTTP error correctly")
    func testExperimentallightclientblockproofHTTPError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForEXPERIMENTALLightClientBlockProof.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForEXPERIMENTALLightClientBlockProof.self, from: requestData)
        let request = requestWrapper.params
        
        // Setup HTTP error response
        setupMockHTTPError(statusCode: 500)
        
        // Execute & Verify
        do {
            _ = try await client.experimentalLightClientBlockProof(request)
            Issue.record("Expected method to throw HTTP error but it succeeded")
        } catch let error as NearJsonRpcError {
            switch error {
            case .httpError(let statusCode):
                #expect(statusCode == 500)
            case .invalidResponse:
                // Some methods might throw invalidResponse instead
                #expect(true)
            default:
                Issue.record("Expected httpError but got: \(error)")
            }
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }

    @Test("EXPERIMENTAL_light_client_proof method executes successfully with mock response")
    func testExperimentallightclientproofSuccess() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForEXPERIMENTALLightClientProof.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForEXPERIMENTALLightClientProof.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock success response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcLightClientExecutionProofResponseAndRpcError_Success.json")
        setupMockSuccessResponse(with: responseData)
        
        // Execute
        let result = try await client.experimentalLightClientProof(request)
        
        // Verify
        verifyRequest(expectedMethod: "EXPERIMENTAL_light_client_proof")
        #expect(result != nil)
    }
    
    @Test("EXPERIMENTAL_light_client_proof method handles error response correctly")
    func testExperimentallightclientproofError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForEXPERIMENTALLightClientProof.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForEXPERIMENTALLightClientProof.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock error response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcLightClientExecutionProofResponseAndRpcError_Error.json")
        setupMockErrorResponse(with: responseData)
        
        // Execute & Verify
        do {
            _ = try await client.experimentalLightClientProof(request)
            Issue.record("Expected method to throw RPC error but it succeeded")
        } catch is NearJsonRpcError {
            // Expected to catch NearJsonRpcError (including rpcError case)
            #expect(true)
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }
    
    @Test("EXPERIMENTAL_light_client_proof method handles HTTP error correctly")
    func testExperimentallightclientproofHTTPError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForEXPERIMENTALLightClientProof.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForEXPERIMENTALLightClientProof.self, from: requestData)
        let request = requestWrapper.params
        
        // Setup HTTP error response
        setupMockHTTPError(statusCode: 500)
        
        // Execute & Verify
        do {
            _ = try await client.experimentalLightClientProof(request)
            Issue.record("Expected method to throw HTTP error but it succeeded")
        } catch let error as NearJsonRpcError {
            switch error {
            case .httpError(let statusCode):
                #expect(statusCode == 500)
            case .invalidResponse:
                // Some methods might throw invalidResponse instead
                #expect(true)
            default:
                Issue.record("Expected httpError but got: \(error)")
            }
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }

    @Test("EXPERIMENTAL_maintenance_windows method executes successfully with mock response")
    func testExperimentalmaintenancewindowsSuccess() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForEXPERIMENTALMaintenanceWindows.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForEXPERIMENTALMaintenanceWindows.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock success response data
        let responseData = try loadMockJSON("JsonRpcResponseForArrayOfRangeOfUint64AndRpcError_Success.json")
        setupMockSuccessResponse(with: responseData)
        
        // Execute
        let result = try await client.experimentalMaintenanceWindows(request)
        
        // Verify
        verifyRequest(expectedMethod: "EXPERIMENTAL_maintenance_windows")
        #expect(result != nil)
    }
    
    @Test("EXPERIMENTAL_maintenance_windows method handles error response correctly")
    func testExperimentalmaintenancewindowsError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForEXPERIMENTALMaintenanceWindows.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForEXPERIMENTALMaintenanceWindows.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock error response data
        let responseData = try loadMockJSON("JsonRpcResponseForArrayOfRangeOfUint64AndRpcError_Error.json")
        setupMockErrorResponse(with: responseData)
        
        // Execute & Verify
        do {
            _ = try await client.experimentalMaintenanceWindows(request)
            Issue.record("Expected method to throw RPC error but it succeeded")
        } catch is NearJsonRpcError {
            // Expected to catch NearJsonRpcError (including rpcError case)
            #expect(true)
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }
    
    @Test("EXPERIMENTAL_maintenance_windows method handles HTTP error correctly")
    func testExperimentalmaintenancewindowsHTTPError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForEXPERIMENTALMaintenanceWindows.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForEXPERIMENTALMaintenanceWindows.self, from: requestData)
        let request = requestWrapper.params
        
        // Setup HTTP error response
        setupMockHTTPError(statusCode: 500)
        
        // Execute & Verify
        do {
            _ = try await client.experimentalMaintenanceWindows(request)
            Issue.record("Expected method to throw HTTP error but it succeeded")
        } catch let error as NearJsonRpcError {
            switch error {
            case .httpError(let statusCode):
                #expect(statusCode == 500)
            case .invalidResponse:
                // Some methods might throw invalidResponse instead
                #expect(true)
            default:
                Issue.record("Expected httpError but got: \(error)")
            }
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }

    @Test("EXPERIMENTAL_protocol_config method executes successfully with mock response")
    func testExperimentalprotocolconfigSuccess() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForEXPERIMENTALProtocolConfig.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForEXPERIMENTALProtocolConfig.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock success response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcProtocolConfigResponseAndRpcError_Success.json")
        setupMockSuccessResponse(with: responseData)
        
        // Execute
        let result = try await client.experimentalProtocolConfig(request)
        
        // Verify
        verifyRequest(expectedMethod: "EXPERIMENTAL_protocol_config")
        #expect(result != nil)
    }
    
    @Test("EXPERIMENTAL_protocol_config method handles error response correctly")
    func testExperimentalprotocolconfigError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForEXPERIMENTALProtocolConfig.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForEXPERIMENTALProtocolConfig.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock error response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcProtocolConfigResponseAndRpcError_Error.json")
        setupMockErrorResponse(with: responseData)
        
        // Execute & Verify
        do {
            _ = try await client.experimentalProtocolConfig(request)
            Issue.record("Expected method to throw RPC error but it succeeded")
        } catch is NearJsonRpcError {
            // Expected to catch NearJsonRpcError (including rpcError case)
            #expect(true)
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }
    
    @Test("EXPERIMENTAL_protocol_config method handles HTTP error correctly")
    func testExperimentalprotocolconfigHTTPError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForEXPERIMENTALProtocolConfig.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForEXPERIMENTALProtocolConfig.self, from: requestData)
        let request = requestWrapper.params
        
        // Setup HTTP error response
        setupMockHTTPError(statusCode: 500)
        
        // Execute & Verify
        do {
            _ = try await client.experimentalProtocolConfig(request)
            Issue.record("Expected method to throw HTTP error but it succeeded")
        } catch let error as NearJsonRpcError {
            switch error {
            case .httpError(let statusCode):
                #expect(statusCode == 500)
            case .invalidResponse:
                // Some methods might throw invalidResponse instead
                #expect(true)
            default:
                Issue.record("Expected httpError but got: \(error)")
            }
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }

    @Test("EXPERIMENTAL_receipt method executes successfully with mock response")
    func testExperimentalreceiptSuccess() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForEXPERIMENTALReceipt.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForEXPERIMENTALReceipt.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock success response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcReceiptResponseAndRpcError_Success.json")
        setupMockSuccessResponse(with: responseData)
        
        // Execute
        let result = try await client.experimentalReceipt(request)
        
        // Verify
        verifyRequest(expectedMethod: "EXPERIMENTAL_receipt")
        #expect(result != nil)
    }
    
    @Test("EXPERIMENTAL_receipt method handles error response correctly")
    func testExperimentalreceiptError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForEXPERIMENTALReceipt.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForEXPERIMENTALReceipt.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock error response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcReceiptResponseAndRpcError_Error.json")
        setupMockErrorResponse(with: responseData)
        
        // Execute & Verify
        do {
            _ = try await client.experimentalReceipt(request)
            Issue.record("Expected method to throw RPC error but it succeeded")
        } catch is NearJsonRpcError {
            // Expected to catch NearJsonRpcError (including rpcError case)
            #expect(true)
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }
    
    @Test("EXPERIMENTAL_receipt method handles HTTP error correctly")
    func testExperimentalreceiptHTTPError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForEXPERIMENTALReceipt.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForEXPERIMENTALReceipt.self, from: requestData)
        let request = requestWrapper.params
        
        // Setup HTTP error response
        setupMockHTTPError(statusCode: 500)
        
        // Execute & Verify
        do {
            _ = try await client.experimentalReceipt(request)
            Issue.record("Expected method to throw HTTP error but it succeeded")
        } catch let error as NearJsonRpcError {
            switch error {
            case .httpError(let statusCode):
                #expect(statusCode == 500)
            case .invalidResponse:
                // Some methods might throw invalidResponse instead
                #expect(true)
            default:
                Issue.record("Expected httpError but got: \(error)")
            }
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }

    @Test("EXPERIMENTAL_split_storage_info method executes successfully with mock response")
    func testExperimentalsplitstorageinfoSuccess() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForEXPERIMENTALSplitStorageInfo.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForEXPERIMENTALSplitStorageInfo.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock success response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcSplitStorageInfoResponseAndRpcError_Success.json")
        setupMockSuccessResponse(with: responseData)
        
        // Execute
        let result = try await client.experimentalSplitStorageInfo(request)
        
        // Verify
        verifyRequest(expectedMethod: "EXPERIMENTAL_split_storage_info")
        #expect(result != nil)
    }
    
    @Test("EXPERIMENTAL_split_storage_info method handles error response correctly")
    func testExperimentalsplitstorageinfoError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForEXPERIMENTALSplitStorageInfo.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForEXPERIMENTALSplitStorageInfo.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock error response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcSplitStorageInfoResponseAndRpcError_Error.json")
        setupMockErrorResponse(with: responseData)
        
        // Execute & Verify
        do {
            _ = try await client.experimentalSplitStorageInfo(request)
            Issue.record("Expected method to throw RPC error but it succeeded")
        } catch is NearJsonRpcError {
            // Expected to catch NearJsonRpcError (including rpcError case)
            #expect(true)
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }
    
    @Test("EXPERIMENTAL_split_storage_info method handles HTTP error correctly")
    func testExperimentalsplitstorageinfoHTTPError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForEXPERIMENTALSplitStorageInfo.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForEXPERIMENTALSplitStorageInfo.self, from: requestData)
        let request = requestWrapper.params
        
        // Setup HTTP error response
        setupMockHTTPError(statusCode: 500)
        
        // Execute & Verify
        do {
            _ = try await client.experimentalSplitStorageInfo(request)
            Issue.record("Expected method to throw HTTP error but it succeeded")
        } catch let error as NearJsonRpcError {
            switch error {
            case .httpError(let statusCode):
                #expect(statusCode == 500)
            case .invalidResponse:
                // Some methods might throw invalidResponse instead
                #expect(true)
            default:
                Issue.record("Expected httpError but got: \(error)")
            }
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }

    @Test("EXPERIMENTAL_tx_status method executes successfully with mock response")
    func testExperimentaltxstatusSuccess() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForEXPERIMENTALTxStatus.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForEXPERIMENTALTxStatus.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock success response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcTransactionResponseAndRpcError_Success.json")
        setupMockSuccessResponse(with: responseData)
        
        // Execute
        let result = try await client.experimentalTxStatus(request)
        
        // Verify
        verifyRequest(expectedMethod: "EXPERIMENTAL_tx_status")
        #expect(result != nil)
    }
    
    @Test("EXPERIMENTAL_tx_status method handles error response correctly")
    func testExperimentaltxstatusError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForEXPERIMENTALTxStatus.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForEXPERIMENTALTxStatus.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock error response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcTransactionResponseAndRpcError_Error.json")
        setupMockErrorResponse(with: responseData)
        
        // Execute & Verify
        do {
            _ = try await client.experimentalTxStatus(request)
            Issue.record("Expected method to throw RPC error but it succeeded")
        } catch is NearJsonRpcError {
            // Expected to catch NearJsonRpcError (including rpcError case)
            #expect(true)
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }
    
    @Test("EXPERIMENTAL_tx_status method handles HTTP error correctly")
    func testExperimentaltxstatusHTTPError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForEXPERIMENTALTxStatus.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForEXPERIMENTALTxStatus.self, from: requestData)
        let request = requestWrapper.params
        
        // Setup HTTP error response
        setupMockHTTPError(statusCode: 500)
        
        // Execute & Verify
        do {
            _ = try await client.experimentalTxStatus(request)
            Issue.record("Expected method to throw HTTP error but it succeeded")
        } catch let error as NearJsonRpcError {
            switch error {
            case .httpError(let statusCode):
                #expect(statusCode == 500)
            case .invalidResponse:
                // Some methods might throw invalidResponse instead
                #expect(true)
            default:
                Issue.record("Expected httpError but got: \(error)")
            }
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }

    @Test("EXPERIMENTAL_validators_ordered method executes successfully with mock response")
    func testExperimentalvalidatorsorderedSuccess() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForEXPERIMENTALValidatorsOrdered.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForEXPERIMENTALValidatorsOrdered.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock success response data
        let responseData = try loadMockJSON("JsonRpcResponseForArrayOfValidatorStakeViewAndRpcError_Success.json")
        setupMockSuccessResponse(with: responseData)
        
        // Execute
        let result = try await client.experimentalValidatorsOrdered(request)
        
        // Verify
        verifyRequest(expectedMethod: "EXPERIMENTAL_validators_ordered")
        #expect(result != nil)
    }
    
    @Test("EXPERIMENTAL_validators_ordered method handles error response correctly")
    func testExperimentalvalidatorsorderedError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForEXPERIMENTALValidatorsOrdered.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForEXPERIMENTALValidatorsOrdered.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock error response data
        let responseData = try loadMockJSON("JsonRpcResponseForArrayOfValidatorStakeViewAndRpcError_Error.json")
        setupMockErrorResponse(with: responseData)
        
        // Execute & Verify
        do {
            _ = try await client.experimentalValidatorsOrdered(request)
            Issue.record("Expected method to throw RPC error but it succeeded")
        } catch is NearJsonRpcError {
            // Expected to catch NearJsonRpcError (including rpcError case)
            #expect(true)
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }
    
    @Test("EXPERIMENTAL_validators_ordered method handles HTTP error correctly")
    func testExperimentalvalidatorsorderedHTTPError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForEXPERIMENTALValidatorsOrdered.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForEXPERIMENTALValidatorsOrdered.self, from: requestData)
        let request = requestWrapper.params
        
        // Setup HTTP error response
        setupMockHTTPError(statusCode: 500)
        
        // Execute & Verify
        do {
            _ = try await client.experimentalValidatorsOrdered(request)
            Issue.record("Expected method to throw HTTP error but it succeeded")
        } catch let error as NearJsonRpcError {
            switch error {
            case .httpError(let statusCode):
                #expect(statusCode == 500)
            case .invalidResponse:
                // Some methods might throw invalidResponse instead
                #expect(true)
            default:
                Issue.record("Expected httpError but got: \(error)")
            }
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }

    @Test("block method executes successfully with mock response")
    func testBlockSuccess() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForBlock.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForBlock.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock success response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcBlockResponseAndRpcError_Success.json")
        setupMockSuccessResponse(with: responseData)
        
        // Execute
        let result = try await client.block(request)
        
        // Verify
        verifyRequest(expectedMethod: "block")
        #expect(result != nil)
    }
    
    @Test("block method handles error response correctly")
    func testBlockError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForBlock.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForBlock.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock error response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcBlockResponseAndRpcError_Error.json")
        setupMockErrorResponse(with: responseData)
        
        // Execute & Verify
        do {
            _ = try await client.block(request)
            Issue.record("Expected method to throw RPC error but it succeeded")
        } catch is NearJsonRpcError {
            // Expected to catch NearJsonRpcError (including rpcError case)
            #expect(true)
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }
    
    @Test("block method handles HTTP error correctly")
    func testBlockHTTPError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForBlock.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForBlock.self, from: requestData)
        let request = requestWrapper.params
        
        // Setup HTTP error response
        setupMockHTTPError(statusCode: 500)
        
        // Execute & Verify
        do {
            _ = try await client.block(request)
            Issue.record("Expected method to throw HTTP error but it succeeded")
        } catch let error as NearJsonRpcError {
            switch error {
            case .httpError(let statusCode):
                #expect(statusCode == 500)
            case .invalidResponse:
                // Some methods might throw invalidResponse instead
                #expect(true)
            default:
                Issue.record("Expected httpError but got: \(error)")
            }
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }

    @Test("block_effects method executes successfully with mock response")
    func testBlockeffectsSuccess() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForBlockEffects.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForBlockEffects.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock success response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcStateChangesInBlockByTypeResponseAndRpcError_Success.json")
        setupMockSuccessResponse(with: responseData)
        
        // Execute
        let result = try await client.blockEffects(request)
        
        // Verify
        verifyRequest(expectedMethod: "block_effects")
        #expect(result != nil)
    }
    
    @Test("block_effects method handles error response correctly")
    func testBlockeffectsError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForBlockEffects.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForBlockEffects.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock error response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcStateChangesInBlockByTypeResponseAndRpcError_Error.json")
        setupMockErrorResponse(with: responseData)
        
        // Execute & Verify
        do {
            _ = try await client.blockEffects(request)
            Issue.record("Expected method to throw RPC error but it succeeded")
        } catch is NearJsonRpcError {
            // Expected to catch NearJsonRpcError (including rpcError case)
            #expect(true)
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }
    
    @Test("block_effects method handles HTTP error correctly")
    func testBlockeffectsHTTPError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForBlockEffects.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForBlockEffects.self, from: requestData)
        let request = requestWrapper.params
        
        // Setup HTTP error response
        setupMockHTTPError(statusCode: 500)
        
        // Execute & Verify
        do {
            _ = try await client.blockEffects(request)
            Issue.record("Expected method to throw HTTP error but it succeeded")
        } catch let error as NearJsonRpcError {
            switch error {
            case .httpError(let statusCode):
                #expect(statusCode == 500)
            case .invalidResponse:
                // Some methods might throw invalidResponse instead
                #expect(true)
            default:
                Issue.record("Expected httpError but got: \(error)")
            }
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }

    @Test("broadcast_tx_async method executes successfully with mock response")
    func testBroadcasttxasyncSuccess() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForBroadcastTxAsync.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForBroadcastTxAsync.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock success response data
        let responseData = try loadMockJSON("JsonRpcResponseForCryptoHashAndRpcError_Success.json")
        setupMockSuccessResponse(with: responseData)
        
        // Execute
        let result = try await client.broadcastTxAsync(request)
        
        // Verify
        verifyRequest(expectedMethod: "broadcast_tx_async")
        #expect(result != nil)
    }
    
    @Test("broadcast_tx_async method handles error response correctly")
    func testBroadcasttxasyncError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForBroadcastTxAsync.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForBroadcastTxAsync.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock error response data
        let responseData = try loadMockJSON("JsonRpcResponseForCryptoHashAndRpcError_Error.json")
        setupMockErrorResponse(with: responseData)
        
        // Execute & Verify
        do {
            _ = try await client.broadcastTxAsync(request)
            Issue.record("Expected method to throw RPC error but it succeeded")
        } catch is NearJsonRpcError {
            // Expected to catch NearJsonRpcError (including rpcError case)
            #expect(true)
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }
    
    @Test("broadcast_tx_async method handles HTTP error correctly")
    func testBroadcasttxasyncHTTPError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForBroadcastTxAsync.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForBroadcastTxAsync.self, from: requestData)
        let request = requestWrapper.params
        
        // Setup HTTP error response
        setupMockHTTPError(statusCode: 500)
        
        // Execute & Verify
        do {
            _ = try await client.broadcastTxAsync(request)
            Issue.record("Expected method to throw HTTP error but it succeeded")
        } catch let error as NearJsonRpcError {
            switch error {
            case .httpError(let statusCode):
                #expect(statusCode == 500)
            case .invalidResponse:
                // Some methods might throw invalidResponse instead
                #expect(true)
            default:
                Issue.record("Expected httpError but got: \(error)")
            }
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }

    @Test("broadcast_tx_commit method executes successfully with mock response")
    func testBroadcasttxcommitSuccess() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForBroadcastTxCommit.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForBroadcastTxCommit.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock success response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcTransactionResponseAndRpcError_Success.json")
        setupMockSuccessResponse(with: responseData)
        
        // Execute
        let result = try await client.broadcastTxCommit(request)
        
        // Verify
        verifyRequest(expectedMethod: "broadcast_tx_commit")
        #expect(result != nil)
    }
    
    @Test("broadcast_tx_commit method handles error response correctly")
    func testBroadcasttxcommitError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForBroadcastTxCommit.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForBroadcastTxCommit.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock error response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcTransactionResponseAndRpcError_Error.json")
        setupMockErrorResponse(with: responseData)
        
        // Execute & Verify
        do {
            _ = try await client.broadcastTxCommit(request)
            Issue.record("Expected method to throw RPC error but it succeeded")
        } catch is NearJsonRpcError {
            // Expected to catch NearJsonRpcError (including rpcError case)
            #expect(true)
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }
    
    @Test("broadcast_tx_commit method handles HTTP error correctly")
    func testBroadcasttxcommitHTTPError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForBroadcastTxCommit.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForBroadcastTxCommit.self, from: requestData)
        let request = requestWrapper.params
        
        // Setup HTTP error response
        setupMockHTTPError(statusCode: 500)
        
        // Execute & Verify
        do {
            _ = try await client.broadcastTxCommit(request)
            Issue.record("Expected method to throw HTTP error but it succeeded")
        } catch let error as NearJsonRpcError {
            switch error {
            case .httpError(let statusCode):
                #expect(statusCode == 500)
            case .invalidResponse:
                // Some methods might throw invalidResponse instead
                #expect(true)
            default:
                Issue.record("Expected httpError but got: \(error)")
            }
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }

    @Test("changes method executes successfully with mock response")
    func testChangesSuccess() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForChanges.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForChanges.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock success response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcStateChangesInBlockResponseAndRpcError_Success.json")
        setupMockSuccessResponse(with: responseData)
        
        // Execute
        let result = try await client.changes(request)
        
        // Verify
        verifyRequest(expectedMethod: "changes")
        #expect(result != nil)
    }
    
    @Test("changes method handles error response correctly")
    func testChangesError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForChanges.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForChanges.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock error response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcStateChangesInBlockResponseAndRpcError_Error.json")
        setupMockErrorResponse(with: responseData)
        
        // Execute & Verify
        do {
            _ = try await client.changes(request)
            Issue.record("Expected method to throw RPC error but it succeeded")
        } catch is NearJsonRpcError {
            // Expected to catch NearJsonRpcError (including rpcError case)
            #expect(true)
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }
    
    @Test("changes method handles HTTP error correctly")
    func testChangesHTTPError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForChanges.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForChanges.self, from: requestData)
        let request = requestWrapper.params
        
        // Setup HTTP error response
        setupMockHTTPError(statusCode: 500)
        
        // Execute & Verify
        do {
            _ = try await client.changes(request)
            Issue.record("Expected method to throw HTTP error but it succeeded")
        } catch let error as NearJsonRpcError {
            switch error {
            case .httpError(let statusCode):
                #expect(statusCode == 500)
            case .invalidResponse:
                // Some methods might throw invalidResponse instead
                #expect(true)
            default:
                Issue.record("Expected httpError but got: \(error)")
            }
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }

    @Test("chunk method executes successfully with mock response")
    func testChunkSuccess() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForChunk.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForChunk.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock success response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcChunkResponseAndRpcError_Success.json")
        setupMockSuccessResponse(with: responseData)
        
        // Execute
        let result = try await client.chunk(request)
        
        // Verify
        verifyRequest(expectedMethod: "chunk")
        #expect(result != nil)
    }
    
    @Test("chunk method handles error response correctly")
    func testChunkError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForChunk.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForChunk.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock error response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcChunkResponseAndRpcError_Error.json")
        setupMockErrorResponse(with: responseData)
        
        // Execute & Verify
        do {
            _ = try await client.chunk(request)
            Issue.record("Expected method to throw RPC error but it succeeded")
        } catch is NearJsonRpcError {
            // Expected to catch NearJsonRpcError (including rpcError case)
            #expect(true)
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }
    
    @Test("chunk method handles HTTP error correctly")
    func testChunkHTTPError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForChunk.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForChunk.self, from: requestData)
        let request = requestWrapper.params
        
        // Setup HTTP error response
        setupMockHTTPError(statusCode: 500)
        
        // Execute & Verify
        do {
            _ = try await client.chunk(request)
            Issue.record("Expected method to throw HTTP error but it succeeded")
        } catch let error as NearJsonRpcError {
            switch error {
            case .httpError(let statusCode):
                #expect(statusCode == 500)
            case .invalidResponse:
                // Some methods might throw invalidResponse instead
                #expect(true)
            default:
                Issue.record("Expected httpError but got: \(error)")
            }
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }

    @Test("client_config method executes successfully with mock response")
    func testClientconfigSuccess() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForClientConfig.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForClientConfig.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock success response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcClientConfigResponseAndRpcError_Success.json")
        setupMockSuccessResponse(with: responseData)
        
        // Execute
        let result = try await client.clientConfig(request)
        
        // Verify
        verifyRequest(expectedMethod: "client_config")
        #expect(result != nil)
    }
    
    @Test("client_config method handles error response correctly")
    func testClientconfigError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForClientConfig.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForClientConfig.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock error response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcClientConfigResponseAndRpcError_Error.json")
        setupMockErrorResponse(with: responseData)
        
        // Execute & Verify
        do {
            _ = try await client.clientConfig(request)
            Issue.record("Expected method to throw RPC error but it succeeded")
        } catch is NearJsonRpcError {
            // Expected to catch NearJsonRpcError (including rpcError case)
            #expect(true)
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }
    
    @Test("client_config method handles HTTP error correctly")
    func testClientconfigHTTPError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForClientConfig.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForClientConfig.self, from: requestData)
        let request = requestWrapper.params
        
        // Setup HTTP error response
        setupMockHTTPError(statusCode: 500)
        
        // Execute & Verify
        do {
            _ = try await client.clientConfig(request)
            Issue.record("Expected method to throw HTTP error but it succeeded")
        } catch let error as NearJsonRpcError {
            switch error {
            case .httpError(let statusCode):
                #expect(statusCode == 500)
            case .invalidResponse:
                // Some methods might throw invalidResponse instead
                #expect(true)
            default:
                Issue.record("Expected httpError but got: \(error)")
            }
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }

    @Test("gas_price method executes successfully with mock response")
    func testGaspriceSuccess() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForGasPrice.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForGasPrice.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock success response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcGasPriceResponseAndRpcError_Success.json")
        setupMockSuccessResponse(with: responseData)
        
        // Execute
        let result = try await client.gasPrice(request)
        
        // Verify
        verifyRequest(expectedMethod: "gas_price")
        #expect(result != nil)
    }
    
    @Test("gas_price method handles error response correctly")
    func testGaspriceError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForGasPrice.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForGasPrice.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock error response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcGasPriceResponseAndRpcError_Error.json")
        setupMockErrorResponse(with: responseData)
        
        // Execute & Verify
        do {
            _ = try await client.gasPrice(request)
            Issue.record("Expected method to throw RPC error but it succeeded")
        } catch is NearJsonRpcError {
            // Expected to catch NearJsonRpcError (including rpcError case)
            #expect(true)
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }
    
    @Test("gas_price method handles HTTP error correctly")
    func testGaspriceHTTPError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForGasPrice.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForGasPrice.self, from: requestData)
        let request = requestWrapper.params
        
        // Setup HTTP error response
        setupMockHTTPError(statusCode: 500)
        
        // Execute & Verify
        do {
            _ = try await client.gasPrice(request)
            Issue.record("Expected method to throw HTTP error but it succeeded")
        } catch let error as NearJsonRpcError {
            switch error {
            case .httpError(let statusCode):
                #expect(statusCode == 500)
            case .invalidResponse:
                // Some methods might throw invalidResponse instead
                #expect(true)
            default:
                Issue.record("Expected httpError but got: \(error)")
            }
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }

    @Test("genesis_config method executes successfully with mock response")
    func testGenesisconfigSuccess() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForGenesisConfig.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForGenesisConfig.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock success response data
        let responseData = try loadMockJSON("JsonRpcResponseForGenesisConfigAndRpcError_Success.json")
        setupMockSuccessResponse(with: responseData)
        
        // Execute
        let result = try await client.genesisConfig(request)
        
        // Verify
        verifyRequest(expectedMethod: "genesis_config")
        #expect(result != nil)
    }
    
    @Test("genesis_config method handles error response correctly")
    func testGenesisconfigError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForGenesisConfig.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForGenesisConfig.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock error response data
        let responseData = try loadMockJSON("JsonRpcResponseForGenesisConfigAndRpcError_Error.json")
        setupMockErrorResponse(with: responseData)
        
        // Execute & Verify
        do {
            _ = try await client.genesisConfig(request)
            Issue.record("Expected method to throw RPC error but it succeeded")
        } catch is NearJsonRpcError {
            // Expected to catch NearJsonRpcError (including rpcError case)
            #expect(true)
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }
    
    @Test("genesis_config method handles HTTP error correctly")
    func testGenesisconfigHTTPError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForGenesisConfig.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForGenesisConfig.self, from: requestData)
        let request = requestWrapper.params
        
        // Setup HTTP error response
        setupMockHTTPError(statusCode: 500)
        
        // Execute & Verify
        do {
            _ = try await client.genesisConfig(request)
            Issue.record("Expected method to throw HTTP error but it succeeded")
        } catch let error as NearJsonRpcError {
            switch error {
            case .httpError(let statusCode):
                #expect(statusCode == 500)
            case .invalidResponse:
                // Some methods might throw invalidResponse instead
                #expect(true)
            default:
                Issue.record("Expected httpError but got: \(error)")
            }
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }

    @Test("health method executes successfully with mock response")
    func testHealthSuccess() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForHealth.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForHealth.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock success response data
        let responseData = try loadMockJSON("JsonRpcResponseForNullableRpcHealthResponseAndRpcError_Success.json")
        setupMockSuccessResponse(with: responseData)
        
        // Execute
        let result = try await client.health(request)
        
        // Verify
        verifyRequest(expectedMethod: "health")
        #expect(result != nil)
    }
    
    @Test("health method handles error response correctly")
    func testHealthError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForHealth.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForHealth.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock error response data
        let responseData = try loadMockJSON("JsonRpcResponseForNullableRpcHealthResponseAndRpcError_Error.json")
        setupMockErrorResponse(with: responseData)
        
        // Execute & Verify
        do {
            _ = try await client.health(request)
            Issue.record("Expected method to throw RPC error but it succeeded")
        } catch is NearJsonRpcError {
            // Expected to catch NearJsonRpcError (including rpcError case)
            #expect(true)
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }
    
    @Test("health method handles HTTP error correctly")
    func testHealthHTTPError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForHealth.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForHealth.self, from: requestData)
        let request = requestWrapper.params
        
        // Setup HTTP error response
        setupMockHTTPError(statusCode: 500)
        
        // Execute & Verify
        do {
            _ = try await client.health(request)
            Issue.record("Expected method to throw HTTP error but it succeeded")
        } catch let error as NearJsonRpcError {
            switch error {
            case .httpError(let statusCode):
                #expect(statusCode == 500)
            case .invalidResponse:
                // Some methods might throw invalidResponse instead
                #expect(true)
            default:
                Issue.record("Expected httpError but got: \(error)")
            }
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }

    @Test("light_client_proof method executes successfully with mock response")
    func testLightclientproofSuccess() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForLightClientProof.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForLightClientProof.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock success response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcLightClientExecutionProofResponseAndRpcError_Success.json")
        setupMockSuccessResponse(with: responseData)
        
        // Execute
        let result = try await client.lightClientProof(request)
        
        // Verify
        verifyRequest(expectedMethod: "light_client_proof")
        #expect(result != nil)
    }
    
    @Test("light_client_proof method handles error response correctly")
    func testLightclientproofError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForLightClientProof.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForLightClientProof.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock error response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcLightClientExecutionProofResponseAndRpcError_Error.json")
        setupMockErrorResponse(with: responseData)
        
        // Execute & Verify
        do {
            _ = try await client.lightClientProof(request)
            Issue.record("Expected method to throw RPC error but it succeeded")
        } catch is NearJsonRpcError {
            // Expected to catch NearJsonRpcError (including rpcError case)
            #expect(true)
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }
    
    @Test("light_client_proof method handles HTTP error correctly")
    func testLightclientproofHTTPError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForLightClientProof.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForLightClientProof.self, from: requestData)
        let request = requestWrapper.params
        
        // Setup HTTP error response
        setupMockHTTPError(statusCode: 500)
        
        // Execute & Verify
        do {
            _ = try await client.lightClientProof(request)
            Issue.record("Expected method to throw HTTP error but it succeeded")
        } catch let error as NearJsonRpcError {
            switch error {
            case .httpError(let statusCode):
                #expect(statusCode == 500)
            case .invalidResponse:
                // Some methods might throw invalidResponse instead
                #expect(true)
            default:
                Issue.record("Expected httpError but got: \(error)")
            }
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }

    @Test("maintenance_windows method executes successfully with mock response")
    func testMaintenancewindowsSuccess() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForMaintenanceWindows.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForMaintenanceWindows.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock success response data
        let responseData = try loadMockJSON("JsonRpcResponseForArrayOfRangeOfUint64AndRpcError_Success.json")
        setupMockSuccessResponse(with: responseData)
        
        // Execute
        let result = try await client.maintenanceWindows(request)
        
        // Verify
        verifyRequest(expectedMethod: "maintenance_windows")
        #expect(result != nil)
    }
    
    @Test("maintenance_windows method handles error response correctly")
    func testMaintenancewindowsError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForMaintenanceWindows.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForMaintenanceWindows.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock error response data
        let responseData = try loadMockJSON("JsonRpcResponseForArrayOfRangeOfUint64AndRpcError_Error.json")
        setupMockErrorResponse(with: responseData)
        
        // Execute & Verify
        do {
            _ = try await client.maintenanceWindows(request)
            Issue.record("Expected method to throw RPC error but it succeeded")
        } catch is NearJsonRpcError {
            // Expected to catch NearJsonRpcError (including rpcError case)
            #expect(true)
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }
    
    @Test("maintenance_windows method handles HTTP error correctly")
    func testMaintenancewindowsHTTPError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForMaintenanceWindows.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForMaintenanceWindows.self, from: requestData)
        let request = requestWrapper.params
        
        // Setup HTTP error response
        setupMockHTTPError(statusCode: 500)
        
        // Execute & Verify
        do {
            _ = try await client.maintenanceWindows(request)
            Issue.record("Expected method to throw HTTP error but it succeeded")
        } catch let error as NearJsonRpcError {
            switch error {
            case .httpError(let statusCode):
                #expect(statusCode == 500)
            case .invalidResponse:
                // Some methods might throw invalidResponse instead
                #expect(true)
            default:
                Issue.record("Expected httpError but got: \(error)")
            }
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }

    @Test("network_info method executes successfully with mock response")
    func testNetworkinfoSuccess() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForNetworkInfo.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForNetworkInfo.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock success response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcNetworkInfoResponseAndRpcError_Success.json")
        setupMockSuccessResponse(with: responseData)
        
        // Execute
        let result = try await client.networkInfo(request)
        
        // Verify
        verifyRequest(expectedMethod: "network_info")
        #expect(result != nil)
    }
    
    @Test("network_info method handles error response correctly")
    func testNetworkinfoError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForNetworkInfo.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForNetworkInfo.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock error response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcNetworkInfoResponseAndRpcError_Error.json")
        setupMockErrorResponse(with: responseData)
        
        // Execute & Verify
        do {
            _ = try await client.networkInfo(request)
            Issue.record("Expected method to throw RPC error but it succeeded")
        } catch is NearJsonRpcError {
            // Expected to catch NearJsonRpcError (including rpcError case)
            #expect(true)
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }
    
    @Test("network_info method handles HTTP error correctly")
    func testNetworkinfoHTTPError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForNetworkInfo.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForNetworkInfo.self, from: requestData)
        let request = requestWrapper.params
        
        // Setup HTTP error response
        setupMockHTTPError(statusCode: 500)
        
        // Execute & Verify
        do {
            _ = try await client.networkInfo(request)
            Issue.record("Expected method to throw HTTP error but it succeeded")
        } catch let error as NearJsonRpcError {
            switch error {
            case .httpError(let statusCode):
                #expect(statusCode == 500)
            case .invalidResponse:
                // Some methods might throw invalidResponse instead
                #expect(true)
            default:
                Issue.record("Expected httpError but got: \(error)")
            }
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }

    @Test("next_light_client_block method executes successfully with mock response")
    func testNextlightclientblockSuccess() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForNextLightClientBlock.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForNextLightClientBlock.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock success response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcLightClientNextBlockResponseAndRpcError_Success.json")
        setupMockSuccessResponse(with: responseData)
        
        // Execute
        let result = try await client.nextLightClientBlock(request)
        
        // Verify
        verifyRequest(expectedMethod: "next_light_client_block")
        #expect(result != nil)
    }
    
    @Test("next_light_client_block method handles error response correctly")
    func testNextlightclientblockError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForNextLightClientBlock.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForNextLightClientBlock.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock error response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcLightClientNextBlockResponseAndRpcError_Error.json")
        setupMockErrorResponse(with: responseData)
        
        // Execute & Verify
        do {
            _ = try await client.nextLightClientBlock(request)
            Issue.record("Expected method to throw RPC error but it succeeded")
        } catch is NearJsonRpcError {
            // Expected to catch NearJsonRpcError (including rpcError case)
            #expect(true)
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }
    
    @Test("next_light_client_block method handles HTTP error correctly")
    func testNextlightclientblockHTTPError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForNextLightClientBlock.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForNextLightClientBlock.self, from: requestData)
        let request = requestWrapper.params
        
        // Setup HTTP error response
        setupMockHTTPError(statusCode: 500)
        
        // Execute & Verify
        do {
            _ = try await client.nextLightClientBlock(request)
            Issue.record("Expected method to throw HTTP error but it succeeded")
        } catch let error as NearJsonRpcError {
            switch error {
            case .httpError(let statusCode):
                #expect(statusCode == 500)
            case .invalidResponse:
                // Some methods might throw invalidResponse instead
                #expect(true)
            default:
                Issue.record("Expected httpError but got: \(error)")
            }
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }

    @Test("query method executes successfully with mock response")
    func testQuerySuccess() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForQuery.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForQuery.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock success response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcQueryResponseAndRpcError_Success.json")
        setupMockSuccessResponse(with: responseData)
        
        // Execute
        let result = try await client.query(request)
        
        // Verify
        verifyRequest(expectedMethod: "query")
        #expect(result != nil)
    }
    
    @Test("query method handles error response correctly")
    func testQueryError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForQuery.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForQuery.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock error response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcQueryResponseAndRpcError_Error.json")
        setupMockErrorResponse(with: responseData)
        
        // Execute & Verify
        do {
            _ = try await client.query(request)
            Issue.record("Expected method to throw RPC error but it succeeded")
        } catch is NearJsonRpcError {
            // Expected to catch NearJsonRpcError (including rpcError case)
            #expect(true)
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }
    
    @Test("query method handles HTTP error correctly")
    func testQueryHTTPError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForQuery.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForQuery.self, from: requestData)
        let request = requestWrapper.params
        
        // Setup HTTP error response
        setupMockHTTPError(statusCode: 500)
        
        // Execute & Verify
        do {
            _ = try await client.query(request)
            Issue.record("Expected method to throw HTTP error but it succeeded")
        } catch let error as NearJsonRpcError {
            switch error {
            case .httpError(let statusCode):
                #expect(statusCode == 500)
            case .invalidResponse:
                // Some methods might throw invalidResponse instead
                #expect(true)
            default:
                Issue.record("Expected httpError but got: \(error)")
            }
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }

    @Test("send_tx method executes successfully with mock response")
    func testSendtxSuccess() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForSendTx.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForSendTx.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock success response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcTransactionResponseAndRpcError_Success.json")
        setupMockSuccessResponse(with: responseData)
        
        // Execute
        let result = try await client.sendTx(request)
        
        // Verify
        verifyRequest(expectedMethod: "send_tx")
        #expect(result != nil)
    }
    
    @Test("send_tx method handles error response correctly")
    func testSendtxError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForSendTx.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForSendTx.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock error response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcTransactionResponseAndRpcError_Error.json")
        setupMockErrorResponse(with: responseData)
        
        // Execute & Verify
        do {
            _ = try await client.sendTx(request)
            Issue.record("Expected method to throw RPC error but it succeeded")
        } catch is NearJsonRpcError {
            // Expected to catch NearJsonRpcError (including rpcError case)
            #expect(true)
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }
    
    @Test("send_tx method handles HTTP error correctly")
    func testSendtxHTTPError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForSendTx.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForSendTx.self, from: requestData)
        let request = requestWrapper.params
        
        // Setup HTTP error response
        setupMockHTTPError(statusCode: 500)
        
        // Execute & Verify
        do {
            _ = try await client.sendTx(request)
            Issue.record("Expected method to throw HTTP error but it succeeded")
        } catch let error as NearJsonRpcError {
            switch error {
            case .httpError(let statusCode):
                #expect(statusCode == 500)
            case .invalidResponse:
                // Some methods might throw invalidResponse instead
                #expect(true)
            default:
                Issue.record("Expected httpError but got: \(error)")
            }
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }

    @Test("status method executes successfully with mock response")
    func testStatusSuccess() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForStatus.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForStatus.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock success response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcStatusResponseAndRpcError_Success.json")
        setupMockSuccessResponse(with: responseData)
        
        // Execute
        let result = try await client.status(request)
        
        // Verify
        verifyRequest(expectedMethod: "status")
        #expect(result != nil)
    }
    
    @Test("status method handles error response correctly")
    func testStatusError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForStatus.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForStatus.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock error response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcStatusResponseAndRpcError_Error.json")
        setupMockErrorResponse(with: responseData)
        
        // Execute & Verify
        do {
            _ = try await client.status(request)
            Issue.record("Expected method to throw RPC error but it succeeded")
        } catch is NearJsonRpcError {
            // Expected to catch NearJsonRpcError (including rpcError case)
            #expect(true)
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }
    
    @Test("status method handles HTTP error correctly")
    func testStatusHTTPError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForStatus.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForStatus.self, from: requestData)
        let request = requestWrapper.params
        
        // Setup HTTP error response
        setupMockHTTPError(statusCode: 500)
        
        // Execute & Verify
        do {
            _ = try await client.status(request)
            Issue.record("Expected method to throw HTTP error but it succeeded")
        } catch let error as NearJsonRpcError {
            switch error {
            case .httpError(let statusCode):
                #expect(statusCode == 500)
            case .invalidResponse:
                // Some methods might throw invalidResponse instead
                #expect(true)
            default:
                Issue.record("Expected httpError but got: \(error)")
            }
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }

    @Test("tx method executes successfully with mock response")
    func testTxSuccess() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForTx.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForTx.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock success response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcTransactionResponseAndRpcError_Success.json")
        setupMockSuccessResponse(with: responseData)
        
        // Execute
        let result = try await client.tx(request)
        
        // Verify
        verifyRequest(expectedMethod: "tx")
        #expect(result != nil)
    }
    
    @Test("tx method handles error response correctly")
    func testTxError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForTx.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForTx.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock error response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcTransactionResponseAndRpcError_Error.json")
        setupMockErrorResponse(with: responseData)
        
        // Execute & Verify
        do {
            _ = try await client.tx(request)
            Issue.record("Expected method to throw RPC error but it succeeded")
        } catch is NearJsonRpcError {
            // Expected to catch NearJsonRpcError (including rpcError case)
            #expect(true)
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }
    
    @Test("tx method handles HTTP error correctly")
    func testTxHTTPError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForTx.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForTx.self, from: requestData)
        let request = requestWrapper.params
        
        // Setup HTTP error response
        setupMockHTTPError(statusCode: 500)
        
        // Execute & Verify
        do {
            _ = try await client.tx(request)
            Issue.record("Expected method to throw HTTP error but it succeeded")
        } catch let error as NearJsonRpcError {
            switch error {
            case .httpError(let statusCode):
                #expect(statusCode == 500)
            case .invalidResponse:
                // Some methods might throw invalidResponse instead
                #expect(true)
            default:
                Issue.record("Expected httpError but got: \(error)")
            }
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }

    @Test("validators method executes successfully with mock response")
    func testValidatorsSuccess() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForValidators.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForValidators.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock success response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcValidatorResponseAndRpcError_Success.json")
        setupMockSuccessResponse(with: responseData)
        
        // Execute
        let result = try await client.validators(request)
        
        // Verify
        verifyRequest(expectedMethod: "validators")
        #expect(result != nil)
    }
    
    @Test("validators method handles error response correctly")
    func testValidatorsError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForValidators.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForValidators.self, from: requestData)
        let request = requestWrapper.params
        
        // Load mock error response data
        let responseData = try loadMockJSON("JsonRpcResponseForRpcValidatorResponseAndRpcError_Error.json")
        setupMockErrorResponse(with: responseData)
        
        // Execute & Verify
        do {
            _ = try await client.validators(request)
            Issue.record("Expected method to throw RPC error but it succeeded")
        } catch is NearJsonRpcError {
            // Expected to catch NearJsonRpcError (including rpcError case)
            #expect(true)
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }
    
    @Test("validators method handles HTTP error correctly")
    func testValidatorsHTTPError() async throws {
        // Setup
        let mockSession = createMockSession()
        let client = NearJsonRpcClient(
            baseURL: URL(string: "https://rpc.testnet.near.org")!,
            session: mockSession
        )
        
        // Load mock request data and extract params
        let requestData = try loadMockJSON("JsonRpcRequestForValidators.json")
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let requestWrapper = try decoder.decode(JsonRpcRequestForValidators.self, from: requestData)
        let request = requestWrapper.params
        
        // Setup HTTP error response
        setupMockHTTPError(statusCode: 500)
        
        // Execute & Verify
        do {
            _ = try await client.validators(request)
            Issue.record("Expected method to throw HTTP error but it succeeded")
        } catch let error as NearJsonRpcError {
            switch error {
            case .httpError(let statusCode):
                #expect(statusCode == 500)
            case .invalidResponse:
                // Some methods might throw invalidResponse instead
                #expect(true)
            default:
                Issue.record("Expected httpError but got: \(error)")
            }
        } catch {
            Issue.record("Expected NearJsonRpcError but got: \(error)")
        }
    }
}

// MARK: - Test Utilities

extension ClientMethodTests {
    
    /// Create a mock URLSession for testing
    func createMockSession() -> URLSession {
        let configuration = URLSessionConfiguration.ephemeral
        configuration.protocolClasses = [MockURLProtocol.self]
        return URLSession(configuration: configuration)
    }
    
    /// Load mock JSON data from file
    func loadMockJSON(_ filename: String) throws -> Data {
        let testBundle = Bundle.module
        guard let url = testBundle.url(
            forResource: filename.replacingOccurrences(of: ".json", with: ""),
            withExtension: "json",
            subdirectory: "Mock"
        ) else {
            throw NSError(
                domain: "TestError",
                code: 1,
                userInfo: [NSLocalizedDescriptionKey: "Mock file not found: \(filename)"]
            )
        }
        return try Data(contentsOf: url)
    }
    
    /// Create a mock HTTP response
    func createHTTPResponse(statusCode: Int = 200) -> HTTPURLResponse {
        return HTTPURLResponse(
            url: URL(string: "https://rpc.testnet.near.org")!,
            statusCode: statusCode,
            httpVersion: nil,
            headerFields: ["Content-Type": "application/json"]
        )!
    }
    
    /// Setup mock response handler for success case
    func setupMockSuccessResponse(with data: Data) {
        MockURLProtocol.requestHandler = { _ in
            let response = HTTPURLResponse(
                url: URL(string: "https://rpc.testnet.near.org")!,
                statusCode: 200,
                httpVersion: nil,
                headerFields: ["Content-Type": "application/json"]
            )!
            return (response, data)
        }
    }
    
    /// Setup mock response handler for error case
    func setupMockErrorResponse(with data: Data) {
        MockURLProtocol.requestHandler = { _ in
            let response = HTTPURLResponse(
                url: URL(string: "https://rpc.testnet.near.org")!,
                statusCode: 200,
                httpVersion: nil,
                headerFields: ["Content-Type": "application/json"]
            )!
            return (response, data)
        }
    }
    
    /// Setup mock response handler for HTTP error
    func setupMockHTTPError(statusCode: Int) {
        MockURLProtocol.requestHandler = { request in
            let response = HTTPURLResponse(
                url: URL(string: "https://rpc.testnet.near.org")!,
                statusCode: statusCode,
                httpVersion: nil,
                headerFields: ["Content-Type": "application/json"]
            )!
            return (response, Data())
        }
    }
    
    /// Verify that a request was made with the expected method
    func verifyRequest(expectedMethod: String) {
        guard let request = MockURLProtocol.lastRequest else {
            Issue.record("No request was captured")
            return
        }
        
        #expect(request.httpMethod == "POST")
        #expect(request.value(forHTTPHeaderField: "Content-Type") == "application/json")
        
        // Decode and verify the request body
        if let body = request.httpBody {
            do {
                let json = try JSONSerialization.jsonObject(with: body) as? [String: Any]
                let method = json?["method"] as? String
                #expect(method == expectedMethod)
            } catch {
                Issue.record("Failed to decode request body: \(error)")
            }
        }
    }
}
